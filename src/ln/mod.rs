use std::sync::Arc;

use async_trait::async_trait;
use cashu_crab::{lightning_invoice::Invoice, Amount, Sha256};
use cln_rpc::model::responses::ListinvoicesInvoicesStatus;
use gl_client::pb::cln::listinvoices_invoices::ListinvoicesInvoicesStatus as GL_ListInvoiceStatus;
use serde::{Deserialize, Serialize};

pub use error::Error;

pub mod cln;
pub mod error;
pub mod greenlight;
pub mod ldk;

#[derive(Clone)]
pub struct Ln {
    /// Payment message sender
    // pub ln_tx: tokio::sync::broadcast::Sender<LnMessage>,
    /// Payment message receiver
    // pub ln_rx: Arc<tokio::sync::broadcast::Receiver<LnMessage>>,
    /// Ln Processor
    pub ln_processor: Arc<dyn LnProcessor>,
}

/// Possible states of an invoice
#[derive(Debug, Serialize, Deserialize, Clone, Copy, PartialEq)]
pub enum InvoiceStatus {
    Unpaid,
    Paid,
    Expired,
    InFlight,
}

impl From<ListinvoicesInvoicesStatus> for InvoiceStatus {
    fn from(status: ListinvoicesInvoicesStatus) -> Self {
        match status {
            ListinvoicesInvoicesStatus::UNPAID => Self::Unpaid,
            ListinvoicesInvoicesStatus::PAID => Self::Paid,
            ListinvoicesInvoicesStatus::EXPIRED => Self::Expired,
        }
    }
}

impl From<GL_ListInvoiceStatus> for InvoiceStatus {
    fn from(status: GL_ListInvoiceStatus) -> Self {
        match status {
            GL_ListInvoiceStatus::Unpaid => Self::Unpaid,
            GL_ListInvoiceStatus::Paid => Self::Paid,
            GL_ListInvoiceStatus::Expired => Self::Expired,
        }
    }
}

impl From<ldk_node::PaymentStatus> for InvoiceStatus {
    fn from(status: ldk_node::PaymentStatus) -> Self {
        match status {
            ldk_node::PaymentStatus::Pending => Self::Unpaid,
            ldk_node::PaymentStatus::Succeeded => Self::Paid,
            ldk_node::PaymentStatus::Failed => Self::Expired,
        }
    }
}

impl ToString for InvoiceStatus {
    fn to_string(&self) -> String {
        match self {
            InvoiceStatus::Paid => "Paid".to_string(),
            InvoiceStatus::Unpaid => "Unpaid".to_string(),
            InvoiceStatus::Expired => "Expired".to_string(),
            InvoiceStatus::InFlight => "InFlight".to_string(),
        }
    }
}

/// Possible states of an invoice
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum InvoiceTokenStatus {
    Issued,
    NotIssued,
}

/// Invoice information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InvoiceInfo {
    /// Payment hash of LN Invoice
    pub payment_hash: Sha256,
    /// random hash generated by the mint to internally look up the invoice state
    pub hash: Sha256,
    pub invoice: Invoice,
    pub amount: Amount,
    pub status: InvoiceStatus,
    pub token_status: InvoiceTokenStatus,
    pub memo: String,
    pub confirmed_at: Option<u64>,
}

impl InvoiceInfo {
    pub fn new(
        payment_hash: Sha256,
        hash: Sha256,
        invoice: Invoice,
        amount: Amount,
        status: InvoiceStatus,
        memo: &str,
        confirmed_at: Option<u64>,
    ) -> Self {
        Self {
            payment_hash,
            hash,
            invoice,
            amount,
            status,
            token_status: InvoiceTokenStatus::NotIssued,
            memo: memo.to_string(),
            confirmed_at,
        }
    }

    pub fn as_json(&self) -> Result<String, Error> {
        Ok(serde_json::to_string(self)?)
    }
}

#[async_trait]
pub trait LnProcessor: Send + Sync {
    async fn get_invoice(
        &self,
        amount: Amount,
        hash: Sha256,
        description: &str,
    ) -> Result<InvoiceInfo, Error>;

    async fn wait_invoice(&self) -> Result<(), Error>;

    async fn pay_invoice(
        &self,
        invoice: Invoice,
        max_fee: Option<Amount>,
    ) -> Result<(String, Amount), Error>;

    async fn check_invoice_status(&self, payment_hash: &Sha256) -> Result<InvoiceStatus, Error>;
}
